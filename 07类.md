# cppp第七章 阅读笔记
    久 等 了

## 1.const成员函数
    参数列表后写一个const描述成员函数，使其不能修改调用对象。（其实就是把隐式this引用变成常引用）

## 2.构造函数
    不能const
    理性思考一下，const还构造个卵
    即使常对象，构造过程也可以修改，构造结束后才打上const标签

## 3.默认构造函数
    没构造函数的话编译器会帮你搓一个 
    如果有了它就不帮你了，如果你还想用它搓：
    MyClass() = default;
    即可

## 4.赋值(拷贝赋值)和拷贝构造
    拷贝构造就是常引用参数constructor
    赋值是对等号的重载
    需要注意的是，在初始化时即使用等号也会走拷贝构造。

    默认拷贝构造和赋值走到都是内置类型直接拷贝，类类型走对应拷贝构造/赋值构造

## 5.友元
    让函数或类称为你的朋友
    直接访问的你私有变量
    声明友元函数或类的主体是友元，而不是对应的函数或类。
    所以得先让他可见才能用它，仅仅告诉编译器他是你的朋友不是用他的前提。

## 6.类内别名
    别名也可以放到类内，甚至可以加访问约束符。
``` cpp
class std::string ... {
    ...
public:
    typedef std::size_t size_type;
    //using size_type = std::size_t;
    ...
}
```

## 7.mutable
    即使在const成员内也能修改的属性可以用mutable修饰。


## 8.类的编译
    编译器在处理类中全部声明后才会去管函数的具体定义。

## 9.类型名相关
    类外类型名如果类内先用，再定义同名类型，则代码有错。
    //但是编译器不管，总之这事别做就好

## 10.构造函数初始值
* 就是冒号后花括号前那一串
* const和引用的唯一初始化机会就在这里了
* 初始化顺序仅参照类内属性声明顺序
* 如果一个构造函数的参数都有默认值，那它就是默认构造函数

## 11.委托构造函数
    "把一函数的温暖，转移到另一个的胸膛，让上次写的码复用出光芒。"

```cpp
class testClass{
public:
    testClass(int a,string b) : a(a),b(b) {};
    testClass(string b) : testClass(0, b) {};
private:
    int a;
    string b;
};
```
## 12.默认初始化与值初始化
默认初始化
* 块作用域内，不用初始值，定义非静态变量
* 合成构造函数对类类型成员
* 类类型成员在构造列表中缺失
值初始化
* 数组初始化，初始值中没有被提供的部分
* 局部静态变量不用初始值定义
* className()

都会走默认构造函数

## 13.隐式类类型转换
    如果构造函数只接一个实参，那么它可以提供隐式类型转换规则。它叫转换构造函数。
    不过这个转换只能一步，不能连链。
    只能用于直接初始化，不能用于赋值构造。

    如果你不想让这种构造函数提供这种功能，请用explicit修饰。

## 14.聚合类
聚合类有如下要求
* 所有成员public
* 没有定义构造函数
* 没有类内初始值
* 没有基类和虚函数
//就是个C struct

    它的特点是可以用花括号初始化（顺序与声明顺序一致）

## 15.字面值常量类
//就是编译时类

要求如下
* 数据成员全部constexpr
* 含有至少一个constexpr构造函数
* 基础数据类型成员若有初始值，则必须是constexpr表达式
* 类类型成员若有初始值，必须调用constexpr构造函数
* 使用析构函数的默认定义

或者
* 是一个充满了constexpr的聚合类

## 16.static相关
    static成员在类初始化的时候不会管
    除非你给他同constexpr修饰并给它初始值
    这时如果你外面不用它就不用在外定义，用的话还是要定义一哈。

---
---
---
后记：

    我突然觉得
        构造函数应该叫构造后函数
        析构函数应该叫析构前函数

    真正对象的构造和析构可轮不到我这个憨憨动手