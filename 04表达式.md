# cppp第四章 阅读笔记

## 1.再谈decltype
    如果decltype直接作用于变量，则取得是它的类型。
    如果作用于除变量以外的表达式，那么当表达式为左值时，取表达式类型的引用，右值则取表达式类型。
``` cpp
    decltype((valA)) tmpD;//int&
    //2.14提到的花活原理，(valA)穿了个马甲就是除变量以外的左值表达式了
```

## 2.除模符号问题
除法 : 同号正，异号负

模<del>法</del> : 结果符号是被模数的符号

等价关系：
    
    (-m)/n === m/(-n) === -(m/n)
    m*(-n) === m%n
    (-m)%n === -(m%n)

## 3.少用后置自增自减
    因为要存副本
    一般来讲，读到后自增的时候当场就会自增，然后返回一个没增过的const副本给你
    当然这东西对内置类型有优化（编译器不傻）
    如果你不理解为啥不能把所有东西都优化成两行来避免拷贝构造副本，请参考(i++ + i++)

## 4.位运算相关
* 左移负数未定义
* 右移负数编译器定义(g++会补符号位)

## 5.sizeof
* 和decltype一样也走的是类型推导，不会真正执行被求值的表达式
* 求引用得被引用对象的大小
* 可以直接求数组，此时数组不会被当指针看
* 不要像个沙雕一样在那sizeof(vector<?>())

## 5.逗号运算符
    从左到右依次执行，整式结果是最右侧
<del>不会真的有人用吧？不会吧？</del>

## 6.何时隐式转型
* 多数表达式中，比int短的往长了转
* 条件中，非布尔转布尔
* 初始化时初始值转为对应类型
* 赋值，右值转左值类型
* 算数表达式转为同类型
* 函数调用

## 7.算数转换

    整形提升 ：就是小整形转成大整形
    无符号相关 ：
        同等级的有符号和无符号运算，结果是无符号
        如果无符号的长，那必是无符号
        如果无符号的短，那就有符号
        （注：原文说的是视环境而定，如果短的无符号都能映射到有符号值域，那结果就是有符号）
## 8.特殊的隐式转型
* 多数用到数组的表达式中，数组被转成它的首指针。<br>
    特别的，当作为decltypy，&，sizeof，typeid的作用对象的时候不转。
* 指针：0和nullptr转成任何指针。<br>
    任何非常量指针转void*<br>
    对象指针转const void*
    对象指针向上转型
    加常量转型
* 类类型自动转换

## 9.显式类型转换
<del>
&emsp;显式类型转换是怎么回事呢？类型转换相信大家都很熟悉，但是显式类型转换是怎么回事呢，下面就让小编带大家一起了解吧。<br>
&emsp;显式类型转换，其实就是强制类型转换，大家可能会很惊讶显式类型转换怎么会是强制类型转换呢？但事实就是这样，小编也感到非常惊讶。<br>
&emsp;这就是关于显式类型转换的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！
</del>

---
cast-name | 描述
-|-
static_cast | 静态转换：<br> 只要不涉及底层const问题都能给你掰过来 <br> 白给精度，回转指针的时候用
dynamic_cast | 动态转换，它第十九章再说
const_cast | 只改底层const
reinterpret_cast | 内存强转，无关类转化

