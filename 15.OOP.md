# cppp第十五章 阅读笔记

    终于碰到对象了

## 1.虚函数
    对于某些函数，基类希望派生类可以自定义适合自身的版本，此时积累将这些函数声明成虚函数。

``` cpp
class MyClass{
    int val;
    virtual int getVal(){
        return val;
    };
};
```

    一个类如果存在被实例化的对象，那么他的所有虚函数都应该被实现。
    否则虚函数表无法生成，这个以后读对象实现的时候会细说。

## 2.动态绑定
    根据对象实际的类型来执行对应的方法
    只有标记了virtual的方法可享受动态绑定
    否则根据对象目前访问方式调用方法。

## 3.protected
    介于公有和私有之间，只给自己儿子看的东西
    刨去protected，子类与外人是一致的，只能看public部分
    子类只能通过对象访问基类的受保护成员，子类的类本身没有访问权限。
    （一句话理解：你不能在子类中拿着父类指针访问父类的protected成员）

## 4.override
    一个描述符，表示本函数重写了基类的虚函数
    给编译器检查用的，没有其他用途

## 5.继承
    class默认是private继承
    struct默认是public继承
    派生类仅声明时不用（也不能）写出类派生列表
    被用作基类的类必须已经被定义
    final可阻止类被继承
    友元和继承没关系。
    子类scope在父类内（不过父亲的private对子类不可见）
    所以你可以同名隐匿（即便参数不同），也可以Base::xxx来指明访问被隐匿的成员

## 6.构造函数相关
    构造函数是不会直接继承过来的
    不过你可以在你的构造函数冒号后面调用父类构造函数
    如果你没有这么做，那么会调用父类的默认构造函数

## 7.静态相关
    静态成员无论如何都不会因为被继承而产生副本
    它仅存在于基类中

## 8.关于继承的类型转换
    首先来说，在对象上不存在类型转换。
    我们只能
        1.转换对对象的访问方式（指针和引用）
        2.用一个对象构造另一个对象
    只有public继承时才允许隐式向上转型（派生类到基类的类型转换）
    向下转型请使用dynamic_cast<>
    如果确定绝对安全，可以使用不经运行时检查的static_cast<>

    同理，泛型容器里请放智能指针，别放父类对象。

## 9.自访问相关
    派生类中的虚函数返回类型必须和基类匹配，不过这存在一个例外：
    基类虚函数返回基类的指针或引用时，派生类也可以返回派生类的指针或引用。
    不过要求必须存在可访问的，由派生类向上转型成基类的类型转换。

## 10.final方法
    阻止覆盖的修饰符，如果父类中被标注final的方法在子类中被覆盖，则报错。
    和override一样，都放到最后。

## 11.虚函数的默认参数
    默认参数的这个原理你应该懂，都是编译期的事
    所以如果某次调用中用了默认实参，那只会参照静态类型。

## 12.强行让它不虚的方法

``` cpp
int value = ptr->Base::func();
//ptr为Base指针，可以指向Base的子类
//func为虚函数，在子类里有自己的实现
//用这句话强行静态执行ptr指向对象中，Base类的func。
```

## 13.纯虚函数
    就是=0
    只能在类内虚函数声明处，外面无效
    不过你可以在外面给一个纯虚函数提供定义
    这样做也不能摆脱抽象，只是子类可以用你这个定义

## 14.继承访问说明符
    继承访问说明符的服务对象是子类，跟自己没关系
    自己该咋访问咋访问，参照父类即可。
    继承访问说明符更像是降级描述符，
    默认private：全都降级到private
    public：不做降级
    protected：public降级为protected.

## 15.向上转型
* public继承时，任意地方都可以向上转型
* 无论继承方式，只要是成员和友元，都可以用向上转型
* 爸爸public或protected继承爷爷，孙子可以使用爸爸的向上转型。

## 16.using改变个别成员的访问性
    using Base::xxx 可以覆写单个被继承成员的访问约束符。
    用在方法上的时候只写名字，不写参数列表，会导入所有的同名方法。

    using也可以用来照抄构造函数，不过这时候不能改访问性。

## 17.虚函数的同名隐匿
    只需要注意是隐藏（隐匿）而不是覆盖
    爷爷的虚函数被爸爸同名隐匿了，儿子依然可以override

## 18.虚化析构函数
    不多提，值得注意的是手动定义虚构函数的类，编译器不会帮你搓移动函数。

## 19.拷贝控制类
    析构隐式链调用，只管自己就好
    其余四个都要显式链调用（如果有必要）